{-
  Contract handles internal messages with queries with the following scheme
  `_# score:uint32 value:(VarUInteger 16) msg:^Cell = MsgInternalBody`, where msg contains message body
  which shoud be sent later and store it to contract.
  Once the number of stored queries reaches 12, contract should send and delete from storage message with
  the highest score and message with the lowest value (if it is the same message, it should be sent once).
  Messages should be sent to any address with mode 0, coin amount should be equal to value and it should contain
  corresponding message body. All scores and values are guaranteed to be different
  Note, that in addition to gas-fees, storage fees will be used to determine final score. In particular,
  storage fee will be calculated like between each message passes 3 days (259200 seconds).
  Gas-units price and storage fee params will correspond to current configs of masterchain:
  1000 nanoTON per 65536 bits per second + 500000 nanoTON per 65536 cells per second; gas is 10000 nanoTON per unit.


  Example:
  (message with score x and value y are represented as `(x,y)` )

  incoming message   outcoming messages     
  (1, 5)           | -
  (2, 6)           | -
  (3, 100)         | -
  (4, 2)           | -
  (5, 3)           | -
  (6, 4)           | -
  (7, 7)           | -
  (8, 8)           | -
  (9, 9)           | -
  (10, 10)         | -
  (11, 11)         | -
  (12, 20)         | (12,20); (4,2)
  (15, 1)          | -
  (13, 13)         | (15, 1)
  (14, 14)         | (14,14); (5,3)
-}

;; testable
() recv_internal (slice in_msg_body) impure {
    (int score, int value, cell msg) = in_msg_body~unpack();
    ;; load number of current messages
    ;; if new can be added withour structure reformat - add
    ;; else - reformat structure
    ;; 1-4 cells - directly in storage cell
    ;; 5-7 cells - first 4 in first parent cell; others directly in storage cell
    ;; 8-11 cells - first 4 in first parent cell; second 4 in second parent cell; third 3 in third parent cell
    (slice storage_sl, int current_number) = read_current_number();
    if ((current_number == 0) | (current_number == 4) | (current_number == 7)) {
        reformat(storage_sl, current_number, score, value, msg);
    } else {
        if (current_number == 11) {
            extract_and_send(storage_sl, score, value, msg);
        } else {
            add_message(storage_sl, current_number, score, value, msg);
        }
    }
}

(slice, int, int, cell) unpack(slice sl) inline_ref {
    int score = sl~load_uint(32);
    int value = sl~load_coins();
    cell msg = sl~load_ref();
    return (sl, score, value, msg);
}

builder pack(builder bl, int score, int value, cell msg) inline_ref {
    return bl.store_uint(score, 32).store_coins(value).store_ref(msg);
}

(slice, int) read_current_number() inline {
    slice storage_sl = get_data().begin_parse();
    if (storage_sl.slice_empty?()) {
        return (storage_sl, 0);
    }
    return storage_sl~load_uint(4);
}

builder write_current_number(int current_number) inline_ref {
    return builder storage_bl = begin_cell().store_uint(current_number, 4);
}

() add_message(slice storage_sl, int current_number, int score, int value, cell msg) impure inline {
    builder storage_bl = write_current_number(current_number + 1);
    if (current_number < 4) {
        ;; 1, 2 or 3
        repeat (3) {
            ifnot (storage_sl.slice_refs_empty?()) {
                storage_bl.pack(storage_sl~unpack());
            }
        }
        storage_bl.pack(score, value, msg).end_cell().set_data();
    } else {
        if (current_number < 7) {
            ;; 5, 6
            storage_bl.store_ref(storage_sl~load_ref());    ;; first node as is
            repeat (2) {
                ifnot (storage_sl.slice_refs_empty?()) {
                    storage_bl.pack(storage_sl~unpack());
                }
            }
            storage_bl.pack(score, value, msg).end_cell().set_data();
        } else {
            if (current_number < 10) {
                ;; 8, 9
                storage_bl.store_ref(storage_sl~load_ref());    ;; first node as is
                storage_bl.store_ref(storage_sl~load_ref());    ;; second node as is

                slice third_sl = storage_sl~load_ref();
                builder third_bl = begin_cell();
                ;; possible 9th message
                ifnot (third_sl.slice_refs_empty?()) {
                    third_bl.pack(third_sl~unpack());
                }
                ;; new message (9th or 10th)
                third_bl.pack(score, value, msg);

                storage_bl.store_ref(third_bl.end_cell());
                storage_bl.end_cell().set_data();
            } else {
                if (current_number == 10) {
                    ;; 10 - check unfilled nodes
                    int packed = 0; ;; false

                    repeat (3) {
                        ifnot (packed) {
                            slice node_sl = storage_sl~load_ref().begin_parse();
                            builder node_bl = begin_cell();
                            repeat (4) {
                                ifnot (node_sl.slice_refs_empty?()) {
                                    node_bl.pack(node_sl~unpack());
                                } else {
                                    ifnot (packed) {
                                        node_bl.pack(score, value, msg);
                                        packed = -1;
                                    }
                                }
                            }
                            storage_bl.store_ref(node_bl.end_cell());
                        } else {
                            storage_bl.store_ref(storage_sl~load_ref());
                        }
                    }
                }
            }
        }
    }
}

() reformat(slice storage_sl, int current_number, int score, int value, cell msg) impure inline {
    builder storage_bl = write_current_number(current_number + 1);
    if (current_number == 0) {
        storage_bl.pack(score, value, msg).end_cell().set_data();
    } else {
        if (current_number == 4) {
            ;; cell first = begin_cell().store_slice(storage_sl).end_cell();
            builder first_bl = begin_cell();
            repeat (4) {
                (int score, int value, cell msg) = storage_sl~unpack();
                first_bl.pack(score, value, msg);
            }
            cell first = first_bl.end_cell();
            storage_bl.store_ref(first)
                    .pack(score, value, msg)
                    .end_cell().set_data();
        } else {
            if (current_number == 7) {
                cell first = storage_bl~load_ref();
                builder second_bl = begin_cell();
                repeat (3) {
                    (int score, int value, cell msg) = storage_sl~unpack();
                    second_bl.pack(score, value, msg);
                }
                cell second = second_bl
                        .pack(score, value, msg)
                        .end_cell();
                cell third = begin_cell().end_cell();
                storage_bl.store_ref(first).store_ref(second).store_ref(third)
                        .end_cell().set_data();
            }
        }
    }
}

() extract_and_send(slice storage_sl, int score, int value, cell msg) impure inline {
    (int max_score, int max_value, int min_value, int same_message) = find_max_min(storage_sl);
    if (same_message) {
        cell max_min_msg = replace_max_min_one(max_score, min_value, score, value, msg);
        send_message(max_min_msg, min_value);
    } else {
        (cell max_msg, cell min_msg) = replace_max_min_two(max_score, min_value, score, value, msg);
        send_message(max_msg, max_value);
        send_message(min_msg, min_value);
    }
}

(int, int, int) find_max_min(slice storage_sl) inline {
    slice node_sl = storage_sl~load_ref().begin_parse();
    (int max_score, int min_value, _) = node_sl~unpack();
    int max_value = max_score;
    int same_message = -1;  ;; true

    repeat (3) {
        repeat (4) {
            ifnot (node_sl.slice_refs_empty?()) {
                (max_score, max_value, min_value, same_message) =
                        node_sl~compare_values(max_score, max_value, min_value, same_message);
            }
        }
        ifnot (storage_sl.slice_refs_empty?()) {
            node_sl = storage_sl~load_ref().begin_parse();
        }
    }

    return (max_score, max_value, min_value, same_message);
}

(slice, int, int, int) compare_values(slice sl, int max_score, int max_value, int min_value, int same_message) inline_ref {
    (int score, int value, _) = sl~unpack();
    int new_same = 0;
    if (score > max_score) {
        max_score = score;
        max_value = value;
        new_same+=1;
    }
    if (value < min_value) {
        min_value = value;
        new_same+=1;
    }
    if (new_same == 1) {
        same_message = 0; ;; false
    } else {
        if (new_same == 2) {
            same_message = -1; ;; true
        }
    }
    return (sl, max_score, max_value, min_value, same_message);
}

(cell) replace_max_min_one(int max_score, int min_value, int score, int value, cell msg) impure inline {
    cell max_min_msg = null();

    builder storage_bl = write_current_number(11);
    slice storage_sl = get_data().begin_parse();
    repeat (3) {
        if (max_min_msg == null()) {
            cell node = storage_sl~load_ref();
            max_min_msg = node~process_max_min_node_one(max_score, min_value, int score, int value, cell msg);
            storage_bl.store_ref(node);
        }
        storage_bl.store_ref(node);
    }

    storage_bl.end_cell().set_data();
    return (max_min_msg);
}

(cell, cell) process_max_min_node_one(slice node_sl, int max_score, int min_value, int new_score, int new_value, cell new_msg) inline {
    builder node_bl = begin_cell();
    cell max_min_msg = null();
    repeat (4) {
        ifnot (node_sl.slice_refs_empty?()) {
            (int score, int value, cell msg) = node_sl~unpack();
            if ((score == max_score) & (value == min_value)) {
                max_min_msg = msg;
                node_bl.pack(new_score, new_value, new_msg);
            } else {
                node_bl.pack(score, value, msg);
            }
        }
    }
    return (node_bl.end_cell(), max_min_msg);
}

(cell, cell) replace_max_min_two(int max_score, int min_value, int score, int value, cell msg) impure inline {
    ;; replace max node, drop min node
    (cell max_msg, cell min_msg) = (null(), null());

    builder storage_bl = write_current_number(10);
    slice storage_sl = get_data().begin_parse();
    repeat (3) {
        if ((max_msg == null()) | (min_msg == null())) {
            cell node = storage_sl~load_ref();
            (max_msg, min_msg) = node~process_max_min_node_two(
                    max_msg, min_msg, max_score, min_value,
                    int score, int value, cell msg);
            storage_bl.store_ref(node);
        }
        storage_bl.store_ref(node);
    }

    storage_bl.end_cell().set_data();
    return (max_msg, min_msg);
}

(cell, cell, cell) process_max_min_node_two(
        slice node_sl, cell max_msg, cell min_msg, int max_score, int min_value,
        int new_score, int new_value, cell new_msg) inline {
    builder node_bl = begin_cell();
    repeat (4) {
        ifnot (node_sl.slice_refs_empty?()) {
            (int score, int value, cell msg) = node_sl~unpack();
            if (score == max_score) {
                max_msg = msg;
                node_bl.pack(new_score, new_value, new_msg);
            } else {
                if (value == min_value) {
                    min_msg = msg;
                    ;; node_bl pack nothing
                } else {
                    node_bl.pack(score, value, msg);
                }
            }
        }
    }
    return (node_bl.end_cell(), max_msg, min_msg);
}

() send_message(cell msg, int value) impure inline_ref {
    var msg_to_sent = begin_cell()
            .store_uint(0x18, 6) ;; tech flags
            .store_slice(my_address())   ;; destination address
            .store_coins(value) ;; attached value
            .store_uint(0, 107) ;; more tech flags :)
            .store_slice(msg.begin_parse())
            .end_cell();

    send_raw_message(msg_to_sent, 0);
}
